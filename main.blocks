<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="t~::xWQ]W..5b82bnOgd" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="!:wR(0mWJ}bsfm5;BW}7" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace elizatools {" line1="" line2="    // Packing into number:  ( r &lt;&lt; 16 ) | (g &lt;&lt; 8 ) | b" line3="    // Sending to ws2812   ---b---g---r---&gt;" line4="    // Added some text to pxt.json to disable BT " line5="    // this helps with console output!" line6="" line7="    //% block=&quot;set ring led $cv&quot;" line8="    //% group=&quot;Ring&quot;" line9="    //% cv.shadow=&quot;colorNumberPicker&quot;" line10="    export function ringDirect(cv: number) {" line11="        let e = pins.createBuffer(25*3)" line12="" line13="        let rColor = (cv &gt;&gt; 16) &amp; 0xFF;" line14="        let gColor = (cv &gt;&gt;  8) &amp; 0xFF;" line15="        let bColor = (cv &gt;&gt;  0) &amp; 0xFF;" line16="" line17="        for (let j = 0; j &lt; 25; j++) {" line18="            e[j * 3 + 0] = gColor;" line19="            e[j * 3 + 1] = rColor;" line20="            e[j * 3 + 2] = bColor;" line21="        }" line22="        // ws2812b.setBufferMode(DigitalPin.P8, ws2812b.BUFFER_MODE_RGB );" line23="        ws2812b.sendBuffer(e, DigitalPin.P8 );" line24="    }" line25="" line26="    //% block=&quot;set head leds $cv&quot;" line27="    //% group=&quot;Ring&quot;" line28="    //% cv.shadow=&quot;colorNumberPicker&quot;" line29="    export function headDirect(cv: number) {" line30="        let f = pins.createBuffer(3 * 3)" line31="" line32="        let rColor2 = (cv &gt;&gt; 16) &amp; 0xFF;" line33="        let gColor2 = (cv &gt;&gt; 8) &amp; 0xFF;" line34="        let bColor2 = (cv &gt;&gt; 0) &amp; 0xFF;" line35="" line36="        for (let k = 0; k &lt; 25; k++) {" line37="            f[k * 3 + 0] = gColor2;" line38="            f[k * 3 + 1] = rColor2;" line39="            f[k * 3 + 2] = bColor2;" line40="        }" line41="" line42="        // ws2812b.setBufferMode(DigitalPin.P16, 1)" line43="        ws2812b.sendBuffer(f, DigitalPin.P16)" line44="" line45="        // ws2812b.setBufferMode(DigitalPin.P16, ws2812b.BUFFER_MODE_RGB);" line46="        // ws2812b.sendBuffer(f, DigitalPin.P16);" line47="    }" line48="" line49="    //% block" line50="    //% group=&quot;Charger&quot;" line51="    export function checkCharger(): boolean {" line52="        let id = i2cReadRegister8( 0x6B, 0x48 )" line53="        // basic.showNumber( id )" line54="        return ( id == 0x19 )" line55="    }" line56="" line57="    //% block" line58="    //% group=&quot;IMU&quot;" line59="    export function checkIMU(): boolean {" line60="        let id2 = i2cReadRegister8( 0x68, 0x75 )" line61="        return (id2 == 0x4E)" line62="    }" line63="" line64="    //% block" line65="    //% group=&quot;Distance&quot;" line66="    export function distance(): number {" line67="        let trig = DigitalPin.P1;" line68="        let echo = DigitalPin.P2;" line69="        let maxCMDistance = 100 * 58;" line70="        " line71="        pins.setPull(trig, PinPullMode.PullNone);" line72="        pins.digitalWritePin(trig, 0);" line73="        control.waitMicros(2);" line74="        pins.digitalWritePin(trig, 1);" line75="        control.waitMicros(10);" line76="        pins.digitalWritePin(trig, 0);" line77="" line78="        // read pulse" line79="        const d = pins.pulseIn(echo, PulseValue.High, maxCMDistance ); " line80="" line81="        return Math.idiv( d, 58 );" line82="    }" line83="" line84="    // " line85="" line86="    let colorSensorConfigured: boolean = false;" line87="    let colorSensorAddress: number = 0x39;" line88="    let colorSensorEnableRegister : number = 0x80;" line89="    let colorSensorATimeRegister  : number = 0x81;" line90="    let colorSensorWTimeRegister  : number = 0x83;" line91="    let colorSensorPersRegister   : number = 0x8C;" line92="    let colorSensorAGainRegister  : number = 0x8F;" line93="    let colorSensorIdRegister     : number = 0x92;" line94="    let colorSensorStatusRegister : number = 0x93;" line95="    let colorSensorRedRegister    : number = 0x96;" line96="    let colorSensorGreenRegister  : number = 0x98;" line97="    let colorSensorBlueRegister   : number = 0x9A;" line98="" line99="    let colorSensorId:number = 0x90;" line100="" line101="    //% block" line102="    //% group=&quot;ColorSensor&quot;" line103="    export function checkColorSensor(): boolean {" line104="        let id3 = i2cReadRegister8(colorSensorAddress, colorSensorIdRegister );" line105="        // basic.showNumber( id )" line106="        return (id3 == colorSensorId )" line107="    }" line108="" line109="    //% block" line110="    //% group=&quot;ColorSensor&quot;" line111="    export function colorSensorReadId(): number {" line112="        let id32 = i2cReadRegister8(colorSensorAddress, colorSensorIdRegister);" line113="        // basic.showNumber( id )" line114="        return id32;" line115="    }" line116="" line117="    //% block" line118="    //% group=&quot;ColorSensor&quot;" line119="    export function colorSensorReadStatus(): number {" line120="        let status = i2cReadRegister8(colorSensorAddress, colorSensorStatusRegister );" line121="        // basic.showNumber( id )" line122="        return status;" line123="    }" line124="" line125="    //% block" line126="    //% group=&quot;ColorSensor&quot;" line127="    export function colorSensorReadEnable(): number {" line128="        let status2 = i2cReadRegister8(colorSensorAddress, colorSensorEnableRegister);" line129="        // basic.showNumber( id )" line130="        return status2;" line131="    }" line132="" line133="    //% block" line134="    //% group=&quot;ColorSensor&quot;" line135="    export function colorSensorRead(): number {" line136="        let rSense:number = 0;" line137="        let bSense:number = 0;" line138="        let gSense:number = 0;" line139="" line140="        colorSensorConfigure();" line141="        " line142="        if (colorSensorConfigured) {" line143="            rSense = i2cReadRegister16(colorSensorAddress, colorSensorRedRegister );" line144="            gSense = i2cReadRegister16(colorSensorAddress, colorSensorGreenRegister );" line145="            bSense = i2cReadRegister16(colorSensorAddress, colorSensorBlueRegister);" line146="        }" line147="" line148="" line149="        let rColor22 = ( rSense &gt;&gt; 8 ) &amp; 0xFF;" line150="        let gColor22 = ( gSense &gt;&gt; 8 ) &amp; 0xFF;" line151="        let bColor22 = ( bSense &gt;&gt; 8 ) &amp; 0xFF;" line152="" line153="        rColor22 = Math.pow( rColor22, 2.5 );" line154="        gColor22 = Math.pow( gColor22, 2.5 );" line155="        bColor22 = Math.pow( bColor22, 2.5 );" line156="" line157="        let cMax = (rColor22 &gt; gColor22) ? rColor22 : gColor22;" line158="        cMax = (bColor22 &gt; cMax) ? bColor22 : cMax;" line159="" line160="        rColor22 = 32 * rColor22 / cMax;" line161="        gColor22 = 32 * gColor22 / cMax;" line162="        bColor22 = 32 * bColor22 / cMax;" line163="" line164="        // basic.showNumber( rColor &gt;&gt; 4 );" line165="" line166="        return (rColor22 &lt;&lt; 16) | (gColor22 &lt;&lt; 8) | bColor22;" line167="        // return (rSense &lt;&lt; 16) | (gSense &lt;&lt; 8) | bSense;" line168="" line169="" line170="   // return rSense + gSense + bSense;" line171="" line172="    }" line173="" line174="    //% block" line175="    //% group=&quot;ColorSensor&quot;" line176="    export function colorGetRed( color:number ): number {" line177="        return ( color &gt;&gt; 16 ) &amp; 0xFF;" line178="    }" line179="" line180="    //% block" line181="    //% group=&quot;ColorSensor&quot;" line182="    export function colorGetGreen(color: number): number {" line183="        return ( color &gt;&gt; 8 ) &amp; 0xFF;" line184="    }" line185="" line186="    //% block" line187="    //% group=&quot;ColorSensor&quot;" line188="    export function colorGetBlue(color: number): number {" line189="        return ( color &amp; 0xFF );" line190="    }" line191="" line192="" line193="    function colorSensorConfigure() {" line194="        if ( !colorSensorConfigured &amp;&amp; checkColorSensor() ) {" line195="            // turn it on" line196="            // Control Reg:  PON" line197="            i2cWriteRegister(colorSensorAddress, colorSensorEnableRegister, 0x01 )" line198="" line199="            basic.pause(100)" line200="" line201="            // ATime  :RGB TIMING:FF 2.4ms, C0 150ms" line202="            i2cWriteRegister(colorSensorAddress, colorSensorATimeRegister, 0xC0 )" line203="            // Wait Time:FF 2.4ms" line204="            i2cWriteRegister(colorSensorAddress, colorSensorWTimeRegister, 0xFF )" line205="            // Persistance: 0x00 - IRQ every time" line206="            i2cWriteRegister(colorSensorAddress, colorSensorPersRegister, 0 )" line207="            // AGain: 0 - 3" line208="            i2cWriteRegister(colorSensorAddress, colorSensorAGainRegister, 3 )" line209="" line210="            // Control Reg:  PON AEN" line211="            i2cWriteRegister(colorSensorAddress, colorSensorEnableRegister, 0x08 | 0x03)" line212="            basic.pause(100)" line213="" line214="" line215="//            basic.showString( &quot;C&quot;);" line216="            colorSensorConfigured = true;" line217="        }" line218="    }" line219="" line220="    //% block=&quot;i2c read8 @ $address reg $register&quot;" line221="    //% group=&quot;I2C&quot;" line222="    export function i2cReadRegister8(address: number, register: number): number {" line223="        pins.i2cWriteNumber(" line224="            address," line225="            register," line226="            NumberFormat.UInt8LE," line227="            true" line228="        )" line229="        return pins.i2cReadNumber(address, NumberFormat.UInt8LE, false)" line230="    }" line231="" line232="    //% block=&quot;i2c read16 @ $address reg $register&quot;" line233="    //% group=&quot;I2C&quot;" line234="    export function i2cReadRegister16(address: number, register: number): number {" line235="        pins.i2cWriteNumber(" line236="            address," line237="            register," line238="            NumberFormat.UInt8LE," line239="            true" line240="        )" line241="        return pins.i2cReadNumber(address, NumberFormat.UInt16LE, false)" line242="    }" line243="" line244="    //% block=&quot;i2c write8 @$address reg $register v $value&quot;" line245="    //% group=&quot;I2C&quot;" line246="    export function i2cWriteRegister8_8(address: number, register: number, value: number) {" line247="        pins.i2cWriteNumber(" line248="            address," line249="            register," line250="            NumberFormat.UInt8LE," line251="            true" line252="        )" line253="        pins.i2cWriteNumber(address, value, NumberFormat.UInt8LE, false)" line254="    }" line255="" line256="    //% block=&quot;i2c write8 @$address reg $register v $value&quot;" line257="    //% group=&quot;I2C&quot;" line258="    export function i2cWriteRegister(address: number, register: number, value: number) {" line259="        pins.i2cWriteNumber(" line260="            address," line261="            register | ( value &lt;&lt; 8 )," line262="            NumberFormat.UInt16LE," line263="            false" line264="        )" line265="        // pins.i2cWriteNumber(address, value, NumberFormat.UInt8LE, false)" line266="    }" line267="" line268="    //% block" line269="    //% group=&quot;Misc&quot;" line270="    // export function showA0() {" line271="    //    basic.showNumber(pins.analogReadPin(AnalogPin.P0))" line272="    // }" line273="" line274="}" numlines="275"></mutation></block></statement></block></xml>