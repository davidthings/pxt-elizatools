<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="t#`if$KYGUk/ENfm6*b%" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="UAp)|13J82:fWK=kEAQ@" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace elizatools {" line1="" line2="    // Packing into number:  ( r &lt;&lt; 16 ) | (g &lt;&lt; 8 ) | b" line3="    // Sending to ws2812   ---b---g---r---&gt;" line4="" line5="    //% block=&quot;set ring led $cv&quot;" line6="    //% group=&quot;Ring&quot;" line7="    //% cv.shadow=&quot;colorNumberPicker&quot;" line8="    export function ringDirect(cv: number) {" line9="        let e = pins.createBuffer(25*3)" line10="" line11="        let rColor = (cv &gt;&gt; 16) &amp; 0xFF;" line12="        let gColor = (cv &gt;&gt;  8) &amp; 0xFF;" line13="        let bColor = (cv &gt;&gt;  0) &amp; 0xFF;" line14="" line15="        for (let j = 0; j &lt; 25; j++) {" line16="            e[j * 3 + 0] = gColor;" line17="            e[j * 3 + 1] = rColor;" line18="            e[j * 3 + 2] = bColor;" line19="        }" line20="        ws2812b.setBufferMode(DigitalPin.P8, ws2812b.BUFFER_MODE_RGB );" line21="        ws2812b.sendBuffer(e, DigitalPin.P8 );" line22="    }" line23="" line24="    //% block=&quot;set head leds $cv&quot;" line25="    //% group=&quot;Ring&quot;" line26="    //% cv.shadow=&quot;colorNumberPicker&quot;" line27="    export function headDirect(cv: number) {" line28="        let f = pins.createBuffer(3 * 3)" line29="" line30="        let rColor2 = (cv &gt;&gt; 16) &amp; 0xFF;" line31="        let gColor2 = (cv &gt;&gt; 8) &amp; 0xFF;" line32="        let bColor2 = (cv &gt;&gt; 0) &amp; 0xFF;" line33="" line34="        for (let k = 0; k &lt; 25; k++) {" line35="            f[k * 3 + 0] = gColor2;" line36="            f[k * 3 + 1] = rColor2;" line37="            f[k * 3 + 2] = bColor2;" line38="        }" line39="        ws2812b.setBufferMode(DigitalPin.P16, ws2812b.BUFFER_MODE_RGB);" line40="        ws2812b.sendBuffer(f, DigitalPin.P16);" line41="    }" line42="" line43="    //% block" line44="    //% group=&quot;Charger&quot;" line45="    export function checkCharger(): boolean {" line46="        let id = i2cReadRegister8( 0x6B, 0x48 )" line47="        // basic.showNumber( id )" line48="        return ( id == 0x19 )" line49="    }" line50="" line51="    //% block" line52="    //% group=&quot;IMU&quot;" line53="    export function checkIMU(): boolean {" line54="        let id2 = i2cReadRegister8( 0x68, 0x75 )" line55="        return (id2 == 0x4E)" line56="    }" line57="" line58="    //% block" line59="    //% group=&quot;Distance&quot;" line60="    export function distance(): number {" line61="        let trig = DigitalPin.P1;" line62="        let echo = DigitalPin.P2;" line63="        let maxCMDistance = 100 * 58;" line64="        " line65="        pins.setPull(trig, PinPullMode.PullNone);" line66="        pins.digitalWritePin(trig, 0);" line67="        control.waitMicros(2);" line68="        pins.digitalWritePin(trig, 1);" line69="        control.waitMicros(10);" line70="        pins.digitalWritePin(trig, 0);" line71="" line72="        // read pulse" line73="        const d = pins.pulseIn(echo, PulseValue.High, maxCMDistance ); " line74="" line75="        return Math.idiv( d, 58 );" line76="    }" line77="" line78="    //% block" line79="    //% group=&quot;ColorSensor&quot;" line80="    export function checkColorSensor(): boolean {" line81="        let id3 = i2cReadRegister8( 41, 178 )" line82="        // basic.showNumber( id )" line83="        return ( id3 == 68 )" line84="    }" line85="" line86="    let colorSensorConfigured : boolean = false;" line87="" line88="    //% block" line89="    //% group=&quot;ColorSensor&quot;" line90="    export function colorSensorRead(): number {" line91="        let rSense = 0;" line92="        let bSense = 0;" line93="        let gSense = 0;" line94="        colorSensorConfigure();" line95="        if (colorSensorConfigured) {" line96="            rSense = i2cReadRegister16(0x29, 0xA0 | 0x16);" line97="            gSense = i2cReadRegister16(0x29, 0xA0 | 0x18);" line98="            bSense = i2cReadRegister16(0x29, 0xA0 | 0x1A);" line99="        }" line100="        let rColor22 = ( rSense &gt;&gt; 8 ) &amp; 0xFF;" line101="        let gColor22 = ( gSense &gt;&gt; 8 ) &amp; 0xFF;" line102="        let bColor22 = ( bSense &gt;&gt; 8 ) &amp; 0xFF;" line103="" line104="        rColor22 = Math.pow( rColor22, 2.5 );" line105="        gColor22 = Math.pow( gColor22, 2.5 );" line106="        bColor22 = Math.pow( bColor22, 2.5 );" line107="" line108="        let cMax = (rColor22 &gt; gColor22) ? rColor22 : gColor22;" line109="        cMax = (bColor22 &gt; cMax) ? bColor22 : cMax;" line110="" line111="        rColor22 = 0x0F * rColor22 / cMax;" line112="        gColor22 = 0x0F * gColor22 / cMax;" line113="        bColor22 = 0x0F * bColor22 / cMax;" line114="" line115="        // basic.showNumber( rColor &gt;&gt; 4 );" line116="" line117="        return ( rColor22 &lt;&lt; 16 ) | (gColor22 &lt;&lt; 8 ) | bColor22;" line118="    }" line119="" line120="    function colorSensorConfigure() {" line121="        if ( !colorSensorConfigured &amp;&amp; checkColorSensor() ) {" line122="            // turn it on" line123="            // Control Reg:  PON AEN" line124="            i2cWriteRegister(0x29, (0x00 + 0x80), 3)" line125="            basic.pause(100)" line126="            // RGB TIMING:FF 2.4ms, C0 150ms, 16b" line127="            i2cWriteRegister(0x29, (0x01 + 0x80), 0xC0 )" line128="            // Wait Time:FF 2.4ms" line129="            i2cWriteRegister(0x29, (0x03 + 0x80), 0xFF )" line130="            // Persistance: 0x00 - IRQ every time" line131="            i2cWriteRegister(0x29, (0x0C + 0x80), 0)" line132="//            basic.showString( &quot;C&quot;);" line133="            colorSensorConfigured = true;" line134="        }" line135="    }" line136="" line137="    //% block=&quot;i2c read8 @ $address reg $register&quot;" line138="    //% group=&quot;I2C&quot;" line139="    export function i2cReadRegister8(address: number, register: number): number {" line140="        pins.i2cWriteNumber(" line141="            address," line142="            register," line143="            NumberFormat.UInt8LE," line144="            true" line145="        )" line146="        return pins.i2cReadNumber(address, NumberFormat.UInt8LE, false)" line147="    }" line148="" line149="    //% block=&quot;i2c read16 @ $address reg $register&quot;" line150="    //% group=&quot;I2C&quot;" line151="    export function i2cReadRegister16(address: number, register: number): number {" line152="        pins.i2cWriteNumber(" line153="            address," line154="            register," line155="            NumberFormat.UInt8LE," line156="            true" line157="        )" line158="        return pins.i2cReadNumber(address, NumberFormat.UInt16LE, false)" line159="    }" line160="" line161="    //% block=&quot;i2c write8 @$address reg $register v $value&quot;" line162="    //% group=&quot;I2C&quot;" line163="    export function i2cWriteRegister(address: number, register: number, value: number) {" line164="        pins.i2cWriteNumber(" line165="            address," line166="            register," line167="            NumberFormat.UInt8LE," line168="            true" line169="        )" line170="        pins.i2cWriteNumber(address, value, NumberFormat.UInt8LE, false)" line171="    }" line172="" line173="" line174="    //% block" line175="    //% group=&quot;Misc&quot;" line176="    export function showA0() {" line177="        basic.showNumber(pins.analogReadPin(AnalogPin.P0))" line178="    }" line179="" line180="}" numlines="181"></mutation></block></statement></block></xml>